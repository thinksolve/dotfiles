#!/usr/bin/env bash
# ~/.dotfiles/bin/recent

set -e

# IDX_FILE=$(mktemp /tmp/recent.idx.XXXXXX)
# IDX_FILE=/tmp/recent.idx
# [[ -s $IDX_FILE ]] || printf 1 >"$IDX_FILE" # create empty if missing

SELF=$(realpath "$0")
RECENT_OPEN="$SELF"

# should create the DB and parent directory if doesnt exist .. behind guard
RECENT_DB=${RECENT_DB:-${XDG_DATA_HOME:-$HOME/.local/share}/recent/files}
RECENT_DIR=$(dirname "$RECENT_DB")

__editable_path() {
    local p=$1
    [[ -d $p ]] && return 0
    case $(file --mime-type -b -- "$p") in
    text/* | application/json | application/x-yaml | application/xml | application/x-shellscript) return 0 ;;
    esac
    return 1
}

_recent_pick() {
    local recent_pick_db="${RECENT_DB:-${XDG_DATA_HOME:-$HOME/.local/share}/shell_recent}"
    local editor="${RECENT_OPEN:-nvim}"
    local dir_viewer="${RECENT_OPEN:-yazi}"
    local filter="${1:-}"
    local pixel_width=$((16 * $(tput cols)))
    local -x _preview_width=$(($pixel_width * 50 / 100))

    #WIP: broken
    #     SAVE_IDX=$(
    #         cat <<'IDX'
    # # printf %s {n} >"$IDX_FILE"
    # printf %s {1} >"$IDX_FILE"
    #
    # IDX
    #     )
    # SAVE_IDX='printf %s {n} >"$IDX_FILE"'

    local FZF_PREVIEW=$(
        cat <<-'PREVIEW'
                printf "\e_Ga=d,d=a\e\\"

                p=$1

                base_name=$(basename "$p")
                safe_name=${base_name//[^[:alnum:]._-]/_}
                hash=$(printf "%s" "$p" | md5sum | cut -d" " -f1)
                tmp="/tmp/preview-$safe_name-$hash"

                if [[ -d "$p" ]]; then
                        echo -e "\033[1;34mDirectory:\033[0m $p\n"
                        tree -a -C -L 2 "$p" 2>/dev/null ||  eza --tree --level=2 --color=always "$p" 2>/dev/null || ls -la "$p"
                elif [[ $p =~ \.(jpe?g|png|gif|webp|tiff|bmp|avif|svg)$ ]]; then
                        kitten icat --silent --transfer-mode=file "$p" 2>/dev/null || echo "Image preview unavailable"
                elif [[ $p =~ \.pdf$ ]]; then
                        pdftoppm -f 1 -l 1 -png -singlefile "$p" "$tmp"
                        kitten icat --silent --transfer-mode=file "${tmp}.png" 2>/dev/null || echo "PDF preview unavailable"
                elif [[ $p =~ \.(mp4|mov|mkv|webm|avi|m4v)$ ]]; then
                        ffmpeg -loglevel error -y -ss 00:00:03 -i "$p" -vframes 1 -vf "scale=$_preview_width:-1" "${tmp}.png"
                        kitten icat --silent --transfer-mode=file "${tmp}.png" 2>/dev/null || echo "Video preview unavailable"
                elif command -v bat >/dev/null; then
                        bat --color=always --style=numbers "$p" 2>/dev/null
                else
                        cat "$p" 2>/dev/null || highlight -O ansi "$p" 2>/dev/null || cat "$p"
                fi
PREVIEW
    )

    #NOTE: WIP: this works but i only want it to work for specific binds not all
    # --bind "load:pos:$(cat "$IDX_FILE" 2>/dev/null || echo 1)" \
    #
    #  --bind "left:execute(printf %s {n} >\"$IDX_FILE\"; parent=\$(cut -f2 <<< {} | xargs dirname) && $editor \"\$parent\" ; \"$0\"'$filter')+abort" \
    #
    tac "$recent_pick_db" 2>/dev/null | while IFS= read -r path; do
        [[ -e "$path" ]] || continue
        if [[ -d "$path" ]]; then
            printf '\e[34mDIR\e[0m\t%s\n' "$path"
        else
            printf '\e[33mFILE\e[0m\t%s\n' "$path"
        fi
    done |
        fzf --preview "bash -c '$FZF_PREVIEW' bash {2}" \
            --preview-window=right:50%:wrap \
            --delimiter=$'\t' \
            --query="$filter" --prompt='recent> ' \
            --header='CTRL-E (edit list); LEFT (parent directory); RIGHT (accept)' \
            --bind "right:accept" \
            --bind "left:execute(parent=\$(cut -f2 <<< {} | xargs dirname) && $editor \"\$parent\" ; \"$0\"'$filter')+abort" \
            --bind "ctrl-e:execute($editor \"$recent_pick_db\" >/dev/tty </dev/tty; \"$0\"'$filter')+abort" \
            --ansi -m |
        awk -F'\t' '{print $2}' | (
        open_now=()
        edit_later=()
        while IFS= read -r pick; do
            [[ -e "$pick" ]] || continue
            if __editable_path "$pick" 2>/dev/null; then
                edit_later+=("$pick")
            else
                open_now+=("$pick")
            fi
        done

        ((${#open_now[@]} + ${#edit_later[@]})) || return 0

        for p in "${open_now[@]}"; do
            open "$p"
        done
        for p in "${edit_later[@]}"; do
            if [[ -d $p ]]; then
                cd "$p" && $dir_viewer .
            else
                $editor "$p"
            fi
        done

        (($? == 0)) && _recent_pick "$filter"
    )
}

_recent_open() {

    # ---- log the first existing argument -------------------------------
    for arg; do
        [[ -e $arg ]] && TARGET=$(realpath "$arg") && break
    done

    [[ ! -e "$TARGET" ]] && {
        echo "recent: no existing files/directories found" >&2
        return 1
    }

    MAX=75

    # ---- pick launcher -------------------------------------------------
    OPENER="" # start empty
    if [[ ${1:-} == --yazi ]]; then
        OPENER=yazi
        shift
    elif [[ ${1:-} == --nvim ]]; then
        OPENER=nvim
        shift
    elif [[ ${1:-} == --open ]]; then
        OPENER=open
        shift
    fi

    # ---- aut_o-detect if no override -----------------------------------
    if [[ -z $OPENER ]]; then
        if [[ -d ${1:-} ]]; then
            OPENER=yazi
        elif __editable_path "$1"; then
            OPENER=nvim
        else
            OPENER=open
        fi
    fi

    if [[ -n ${TARGET:-} ]]; then
        tmp=$(mktemp)
        [[ -f $RECENT_DB ]] && grep -Fxv "$TARGET" "$RECENT_DB" >"$tmp" || true
        printf '%s\n' "$TARGET" >>"$tmp"
        tail -n "$MAX" "$tmp" >"$tmp.2" && mv "$tmp.2" "$RECENT_DB"
        rm -f "$tmp"
    fi

    exec "$OPENER" "$@"

}

case "$1" in
"" | pick) _recent_pick "${@:2}" ;; #NOTE: with 'pick' then the second argument is a filter on the pick list! nice
open) _recent_open "${@:2}" ;;
*) _recent_open "$@" ;;
esac
